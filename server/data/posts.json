[
    {
      "slug": "basics-of-angular",
      "date": "2024-11-01",
      "title": "Basics of Angular",
      "description": "Setting up your first Angular project",
      "tags": ["learning"],
      "content":"For work, I need to learn Angular, so I’m putting together some basics here for future reference.\n\nAfter searching far and wide for a good Angular course, I couldn’t find any free ones that worked for me. Based on a Reddit recommendation, I ended up buying [Maximilian Schwarzmüller’s Angular course on Udemy](https://www.udemy.com/share/101WgA3@vaCMYeslq7ZYL7inswM0z_DBOx3BxOioM5OMD_zYgypg1JcVDUfDI0YJEFbPY2VrzQ==/). (I got lucky, because it was on sale!) While I didn’t finish it and don’t plan to, I still recommend it. The course is easy to follow, and he keeps it updated.\n\nAngular is one of the top front-end JavaScript frameworks, widely used for large-scale applications, and is created and maintained by Google. With Angular, you can create single-page applications (SPAs), where the entire site loads in one go, instead of a typical website that loads pages one by one. For large applications, the initial load might take a bit longer, but everything is smooth afterward.\n\nUsing Angular means using TypeScript instead of JavaScript. Typescript is the same as JavaScript but with a more structured syntax, which helps prevent errors. TypeScript is compiled into JavaScript so that browsers can read it.\n\nApplications in Angular are made up of components, which act as building blocks that make Angular modular and maintainable. Each component comes with four main files by default:\n- HTML file for the layout\n- TypeScript file for the component logic\n- CSS file for styling\n- Spec file for unit testing\n\nThere’s so much more to Angular, like dependency injections, two-way binding, signals, debugging, modules, Auth Guards… Just to keep things organized, I feel like they each would need its own post with examples and explanations. Here’s a little starter tutorial on setting up an Angular project. My end goal is to make a Note app that will be on my GitHub.\n\n<br/>\n\n### Getting Started with an Angular Project\n\n1.\t***Install Angular CLI globally***: In your command prompt, install Angular CLI and verify the installation.\n```plaintext\nnpm install -g @angular/cli\nng version\n```\n\n2.\t***Create a new Project***: First, navigate to the directory where you want your project to be located. Then use the command below to create a new Angular project (mine is named \"Notes\").\n```plaintext\nng new notes\n```\n-\tYou’ll be asked if you want to share data with Google. I said no, but it doesn’t matter.\n- Then, select your preferred stylesheet format. I chose CSS since I’m not familiar with the other ones.\n-\tYou’ll also be asked about enabling Server-Side Rendering (SSR) and Static Site Generation (SSG/Prerendering). For a single Page Application, say no. [Here](https://angularstart.com/modules/angular-getting-started/1/) you can find more details on this.\n\n3.\t***Open the project in Visual Studio Code (VSC)***\n\n4.\t***Run the app***: To run the app you type ng serve in the terminal. Or, if you go in the package.json, you’ll notice that you can also run the app with npm run start. Then, just like the terminal says you go to http://localhost:4200/. \nNow you’re ready to start building your Angular project!\n"
    },
    {
      "slug": "basics-of-elasticsearch",
      "date": "2024-10-22",
      "title": "Basics of Elasticsearch",
      "description": "What is it? How to install? What makes it elastic?",
      "tags": ["learning"],
      "content": "Lately, I’ve been learning the basics of Elasticsearch, so while I take notes, may as well make a post about it.While researching it and looking for tutorials, I came across their Youtube channel. So not only do they have a complete documentation of their open-source database, but they also have advocates that make tutorials. [Here](https://youtube.com/playlist?list=PL_mJOmq4zsHbcdoeAwNWuhEWwDARMMBta\\&si=ZA-i1_hXM3oow_Zl \"Here\")'s the playlist that I like the most, it’s composed of bite-size videos instead of long format ones.\n\n### What is Elasticsearch?\n\nElasticsearch is an open-source database optimized for searching within large datasets. While it can be used as a regular database, this engine shines best in its many searching abilities. It is optimized for fast data retrieval, advance querying and analytics. Many companies that have huge databases use it, like Uber and Tinder. It operates through a RESTful API. It doesn’t just let you get your data it also has the option to get information about that data, like how many times a word is used or how many times that data has been searched.\n\nThe difference between Elasticsearch and a classic database, which is primarily used for storage, is that Elasticsearch’s primary goal is to provide near-instant full-text search and data aggregation.The data aggregation can be used to have statistics on said data.\n\n### Terminology\n\nElasticsearch has a structure that may feel familiar if you’ve worked with databases before, but it uses different terms:\n\n* Index: Similar to a collection in MongoDB or a table in SQL. It’s a logical namespace to group documents together. \n* Id: Every document has its own unique identifier. \n* Document: A JSON object that contains data. In SQL terms, a document is equivalent to a row in a table. \n* Field: Represents individual attributes in the document, similar to a column in a table. \n* Node: A single instance of Elasticsearch running on a server or machine. \n* Shard: Elasticsearch automatically divides indexes into smaller pieces called shards, where documents are stored. \n* Cluster: A group of nodes working together. Each node in the cluster holds data and participates in indexing and searching. \n* Mapping: Defines the fields and data types of an index.\n\n### Why is it called Elasticsearch?\n\nElasticsearch is called that because it automatically scales and distributes data across multiple nodes,allowing it to handle large, dynamic datasets while providing fast and flexible search and real-time analytics.\n\n### Kibana or no Kibana?\n\nIf you want to use Elasticsearch, you’ll probably want to install kibana as well. Kibana is an open-source data visualization dashboard for Elasticsearch, allowing you to query your data, create charts, and monitor your Elasticsearch environment.\n\nIn a way, to reuse what we already about data bases, Kibana acts like SQL Developer but works just like Postman. It lets you query and interact with your Elasticsearch data. Instead of SQL queries, you write REST API queries. And it serves as a visual interface for making REST API requests, allowing you to interact with the Elasticsearch APIs, much like Postman does for general API testing.\n\n<br/>\n<hr/>\n\n### How to Install Elasticsearch and Kibana on Windows and Run Locally\n\nNow, for the hardest part: installing Elasticsearch and Kibana and making them work for the first time. Here’s how I installed Elasticsearch and Kibana and made them work:\n\n1. Download Elasticsearch and Kibana: Extract them to a suitable location. I put them directly in C:\\\\.\n2. Start Elasticsearch: Open a command prompt, navigate to C:\\elasticsearch-8.15.3\\bin, and run elasticsearch.bat. Wait until Elasticsearch is fully started.\n3. Access Elasticsearch: Open a browser and go to localhost:9200. If it asks for a username and password, it means Elasticsearch is working.\n4. Reset Password: Open a new command prompt without stopping elasticsearch.bat and run elasticsearch-reset-password.bat -i -u elastic. Set a new password.\n5. Verify Access: Log in with the username elastic and the password you set. You should see a JSON document.\n6. Configure Elasticsearch: Open C:\\elasticsearch-8.15.3\\config\\elasticsearch.yml and add:\n```\n   cluster.name: my-application\n   node.name: node-1\n   path.data: C:\\elasticsearch-8.15.3\\data\n   path.logs: C:\\elasticsearch-8.15.3\\logs\n   network.host: 0.0.0.0\n   http.port: 9200\n   xpack.security.enabled: false\n   discovery.seed_hosts: [\"127.0.0.1\"]\n   cluster.initial_master_nodes: [\"node-1\"]\n```\n7. Restart Elasticsearch: Run elasticsearch.bat again.\n8. Configure Kibana: Open C:\\kibana-8.15.3\\config\\kibana.yml and add:\n```\n   server.host: \"0.0.0.0\"\n   elasticsearch.hosts: [\"http://localhost:9200/\"]\n```\n   \n9. Start Kibana: Open a new command prompt, navigate to C:\\kibana-8.15.3\\bin, and run kibana.bat. Then go to localhost:5601.\n\nAnd that’s it! You are now ready to mess around with Elasticsearch."
    },
    {
        "slug": "hello-world",
        "date": "2024-09-02",
        "title": "Hello, World!",
        "description": "First blog post.",
        "tags": ["meta"],
        "content": "It's a tradition in programming to start with 'Hello, World!' So welcome to my personal space on the internet. Here I will document my experiences, challenges, and probably other unrelated stuff."
      }
      ,
    {
        "slug": "git-cheat-sheet",
        "date": "2024-09-07",
        "title": "My Git Commands Cheat Sheet",
        "description": "Configurations, repository setup, cloning, committing changes, managing branches, and handling pushes and pulls",
        "tags": ["technical"],
        "content": "Welcome to my personal Git cheat sheet. Although we often use shortcuts in tools like Visual Studio or GitHub Desktop, for work I’ve had to learn some of the more fundamental Git commands. Below are the ones I've used or might need in the future, with explanations.\n<br /><br />\n\n## Git Configuration\n\nFirst, make sure Git is installed by checking the version:\n```plaintext\ngit --version \n```\n\nThen, configure your username and email so that other developers know who committed the changes:\n```plaintext\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"youremail@example.com\"\n```\n\nTo verify the configuration:\n```plaintext\ngit config --global user.name\ngit config --global user.email\n```\nOnce set, these commands won't be needed often unless you're setting up Git on a new machine.\n<br /><br />\n## Setting up a Repository \n\nTo create a new Git repository in an existing project, use:\n```plaintext\ngit init\n```\n\n<br /><br />\n## Cloning a Repository\nTo clone an existing repository to your local machine:\n```plaintext\ngit clone [url]\n```\n- `[url]` is the URL of the remote repository (e.g., `https://github.com/username/repository.git`).\nThis command creates a copy of the repository on your local machine and sets up the default remote to the original repository.\n\n<br /><br />\n## .gitignore File\nDon't forget to create the `.gitignore` file! Before learning about Git, I didn’t realize how important this file is. It’s crucial for every project, so make sure it’s always up to date.\n\nThe `.gitignore` file tells Git which files or directories to ignore. For example, if you use Node.js, it's common to ignore the `/node_modules` folder, as it's large and doesn't need to be pushed with your code. Other developers can run the `npm install` command to install the necessary dependencies.\n\nAlso, it helps prevent sensitive files, like those containing local variables (e.g., `.env`), from being exposed. Accidentally committing API keys or tokens can lead to security risks, such as unexpected charges if an API's usage limit is exceeded.\n\nHere's an example\n```plaintext\nnode_modules/\n.env\n```\n\n<br /><br />\n## Committing Changes\n\nTo commit all your changes at once, use:\n```plaintext\ngit commit -a -m \"commit message\"\n```\n\n- `-a` stages all modified tracked files, so they are ready for the commit.\n- `-m \"commit message\"` allows you to add a commit message directly, bypassing the editor.\n\nAlternatively, you can manually stage changes with:\n```plaintext\ngit add .\n```\n\nThis stages all changes, or you can stage individual files by specifying their paths:\n```plaintext\ngit add [file-path]\n```\nIt's important to note that only staged files will be committed.\n\n<br /><br />\n## Pushing and Pulling Changes\nTo push your commits to a remote repository (such as GitHub or GitLab):\n```plaintext\ngit push origin [branch]\n```\n- `origin` refers to the default name of your remote repository.\n- `[branch]` is the name of the branch you want to push to (e.g., main or master).\n\nTo pull changes from a remote repository into your local branch:\n```plaintext\ngit pull origin [branch]\n```\n- This fetches changes from the remote repository and merges them into your local branch.\n\n\n<br /><br />\n## Restoring Changes\n\nTo discard changes and restore files to their previous state:\n\n- For modified but unstaged files:\n```plaintext\ngit restore .\n```\n\n- For staged files:\n```plaintext\ngit restore --staged .\n```\n\n- For both:\n```plaintext\ngit reset --hard\n```\n\n<br /><br />\n## Viewing Commit History\n\nTo see the full commit history, use:\n```plaintext\ngit log\n```\n\nThis shows detailed information like the author’s name, email, date, and commit message. If this is too verbose, you can use a more concise view:\n```plaintext\ngit log --oneline\n```\nThis provides a simplified commit history, displaying only the commit hash and message.\n\n\n<br /><br />\n## Working with Branches\n\nBranching is essential for managing features and versions. Here are the most common branch-related commands:\n\n- See all branches:\n```plaintext\ngit branch --list\n```\n\n- Check which branch you're currently on:\n```plaintext\ngit branch --show-current\n```\n\n- Create a new branch:\n```plaintext\ngit branch [newBranch]\n```\n\n- Switch to another branch:\n```plaintext\ngit checkout [otherBranch]\n```\n\n- Merge another branch into the current branch:\n```plaintext\ngit merge [otherBranch]\n```"
    }
    ,
    {
        "slug": "what-even-is-an-api",
        "date": "2024-09-27",
        "title": "What Even Is an API?",
        "description": "API stands for Application Programming Interface, but what does that even mean?",
        "tags": ["learning"],
        "content": 
      "API stands for Application Programming Interface, but that doesn’t really answer the question, does it? In fact, it probably raises more questions, like: I thought APIs were backend stuff and had nothing to do with interfaces. Is it a server? What even is a server?\n\nFrom what I’m learning, an API abstracts backend stuff, letting you do things like adding routes with just a bit of code. I still can’t fully wrap my head around how the backend works, and that’s kind of the point. An API is an interface that lets you work with the backend without needing to know all the gritty details. You just need to understand what each function does. Its purpose is to make it so you don’t have to reinvent the wheel.\n\nFor example, Node.js is often used to create APIs. It’s built from a bunch of packages created by other developers, and you don’t need to know exactly how they work to use them, just like you dont need to know how to cook to oder at a restaurant. You can find all these packages and their commands [here](https://www.npmjs.com/).\n\nWhile learning about APIs, I kept trying to understand them the same way I think about frontend development, but the whole idea of Node.js is to abstract a lot of backend complexity. Also, you can’t create APIs with just vanilla JavaScript because you need something called a runtime environment.\n\nSo, what’s a runtime environment? It’s a program that runs your code continuously. So… is that a server? I’m still figuring it out, but it seems like every time I answer one question, another one pops up!\n"
    }
]